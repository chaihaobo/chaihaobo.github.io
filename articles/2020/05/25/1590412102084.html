<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="theme-color" content="#3b3e43"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no"/><title>Flink的Watermark机制 - chaihaobo </title><meta name="description" content=""/><meta property="og:description" content=""/>    <meta name="keywords" content="java,数据"/><link rel="dns-prefetch" href="https://chaihaobo.github.io"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://chaihaobo.github.io"><link rel="icon" type="image/png" href="https://modoo.oss-cn-beijing.aliyuncs.com/u%3D2355059236%2C1504112045%26fm%3D26%26gp%3D0.jpg"/><link rel="apple-touch-icon" href="https://modoo.oss-cn-beijing.aliyuncs.com/u%3D2355059236%2C1504112045%26fm%3D26%26gp%3D0.jpg"><link rel="shortcut icon" type="image/x-icon" href="https://modoo.oss-cn-beijing.aliyuncs.com/u%3D2355059236%2C1504112045%26fm%3D26%26gp%3D0.jpg"><meta name="copyright" content="B3log"/><meta http-equiv="Window-target" content="_top"/><meta property="og:locale" content="zh_CN"/><meta property="og:title" content="Flink的Watermark机制 - chaihaobo "/><meta property="og:site_name" content="chaihaobo "/><meta property="og:url"      content="https://chaihaobo.github.io/articles/2020/05/25/1590412102084.html?"/><meta property="og:image" content="https://modoo.oss-cn-beijing.aliyuncs.com/u%3D2355059236%2C1504112045%26fm%3D26%26gp%3D0.jpg"/><link rel="search" type="application/opensearchdescription+xml" title="Flink的Watermark机制 - chaihaobo " href="/opensearch.xml"><link href="https://chaihaobo.github.io/rss.xml" title="RSS" type="application/rss+xml" rel="alternate"/><link rel="manifest" href="https://chaihaobo.github.io/manifest.json">        <link rel="canonical" href="https://chaihaobo.github.io/articles/2020/05/25/1590412102084.html">        <link rel="stylesheet" href="https://chaihaobo.github.io/skins/nexmoe/css/base.css?1590205324215"/>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
        <link rel="stylesheet" href="https://chaihaobo.github.io/skins/nexmoe/css/font-icon.css?1590205324215">
    </head>
<body class="mdui-drawer-body-left mdui-loaded">
<div id="nexmoe-background">
    <canvas id="c_n1" class="nexmoe-bg"></canvas>
<div class="mdui-appbar mdui-shadow-0">
    <div class="mdui-toolbar">
        <a href="#" mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon">
            <i class="mdui-icon  iconfont solo-list"></i>
        </a>
        <div class="mdui-toolbar-spacer"></div>
        <a href="/" title="chaihaobo " class="mdui-btn mdui-btn-icon">
            <img src="https://modoo.oss-cn-beijing.aliyuncs.com/u%3D2355059236%2C1504112045%26fm%3D26%26gp%3D0.jpg" title="chaihaobo " alt="chaihaobo "></a>
        </a>
    </div>
</div>
</div>
<div id="nexmoe-header">
<div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="https://chaihaobo.github.io/" title="chaihaobo ">
            <img src="https://modoo.oss-cn-beijing.aliyuncs.com/u%3D2355059236%2C1504112045%26fm%3D26%26gp%3D0.jpg" title="chaihaobo " alt=""></a>
    </div>
    <div class="nexmoe-count">
        <div>
            <span>文章</span>
            6
        </div>
        <div>
            <span class="ft-gray">浏览</span>
            <b class="notb" data-uvstaturl="https://chaihaobo.github.io">0</b>
        </div>
    </div>
    <div class="list-content">
        <ul class="nexmoe-list mdui-list header__nav" mdui-collapse="{accordion: true}">
            <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="https://chaihaobo.github.io/" title="chaihaobo ">
                <i class="mdui-list-item-icon iconfont solo-home"></i>
                <div class="mdui-list-item-content">回到首页</div>
            </a>
            <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="https://chaihaobo.github.io/links.html"
               title="友情链接 - chaihaobo ">
                <i class="mdui-list-item-icon iconfont solo-list"></i>
                <div class="mdui-list-item-content">友情链接</div>
            </a>
            <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="https://chaihaobo.github.io/tags.html"
               title="标签 - chaihaobo ">
                <i class="mdui-list-item-icon iconfont solo-tags"></i>
                <div class="mdui-list-item-content">标签</div>
            </a>
                <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/my-github-repos"
                   title="我的开源" target="_self">
                    <i class="mdui-list-item-icon iconfont solo-/images/github-icon.png"></i>
                    <div class="mdui-list-item-content">我的开源</div>
                </a>
        </ul>
    </div>
    <aside id="nexmoe-sidebar">

        <div class="nexmoe-widget-wrap">
            <h3 class="nexmoe-widget-title">功能按钮</h3>
            <div class="nexmoe-widget nexmoe-social features">
                <a href="https://chaihaobo.github.io/search" title="搜索">
                    <i class="mdui-list-item-icon iconfont solo-search"></i>
                    <div class="mdui-list-item-content">搜索</div>
                </a>
                <a href="https://chaihaobo.github.io/rss.xml" title="RSS">
                    <i class="mdui-list-item-icon iconfont solo-rss"></i>
                </a>
                    <a href="https://chaihaobo.github.io/start" title="开始使用">
                        <i class="mdui-list-item-icon iconfont solo-login"></i>
                        <div class="mdui-list-item-content"> 开始使用</div>
                    </a>
            </div>
        </div>

        <div class="nexmoe-widget-wrap">
            <h3 class="nexmoe-widget-title">社交按钮</h3>
            <div class="nexmoe-widget nexmoe-social">
            </div>
        </div>

            <div class="nexmoe-widget-wrap">
                <h3 class="nexmoe-widget-title">标签</h3>
                <div class="nexmoe-widget tagcloud">
                        <a rel="tag"
                           href="https://chaihaobo.github.io/tags/%E5%BE%85%E5%88%86%E7%B1%BB"
                           title="标签:待分类 - chaihaobo "
                           class="mdui-ripple">
                            待分类</a>
                        <a rel="tag"
                           href="https://chaihaobo.github.io/tags/elastic"
                           title="标签:elastic - chaihaobo "
                           class="mdui-ripple">
                            elastic</a>
                        <a rel="tag"
                           href="https://chaihaobo.github.io/tags/%E5%BC%80%E6%BA%90"
                           title="标签:开源 - chaihaobo "
                           class="mdui-ripple">
                            开源</a>
                        <a rel="tag"
                           href="https://chaihaobo.github.io/tags/GitHub"
                           title="标签:GitHub - chaihaobo "
                           class="mdui-ripple">
                            GitHub</a>
                        <a rel="tag"
                           href="https://chaihaobo.github.io/tags/Linux"
                           title="标签:Linux - chaihaobo "
                           class="mdui-ripple">
                            Linux</a>
                        <a rel="tag"
                           href="https://chaihaobo.github.io/tags/Flink"
                           title="标签:Flink - chaihaobo "
                           class="mdui-ripple">
                            Flink</a>
                </div>
            </div>



            <div class="nexmoe-widget-wrap">
                <h3 class="nexmoe-widget-title">存档</h3>
                <div class="nexmoe-widget">
                    <ul class="category-list">
                                <li class="category-list-item">
                                    <a href="https://chaihaobo.github.io/archives/2020/05"
                                       title="2020 年 05 月 存档 - chaihaobo ">
                                        2020 年 05 月</a>
                                    <span class="category-list-count">6</span>
                                </li>
                    </ul>
                </div>
            </div>

    </aside>
    <div class="nexmoe-copyright">
        © 2020 <a href="https://chaihaobo.github.io">chaihaobo </a> <br/>
         <br>
        Powered by <a href="https://solo.b3log.org" target="_blank">Solo</a> <br>
        Theme <a rel="friend" href="https://github.com/InkDP/solo-nexmoe" target="_blank">nexmoe</a>
        by <a rel="friend" href="https://www.inkdp.cn" target="_blank">InkDP</a>
    </div>
</div>
</div>
<div id="nexmoe-content">
    <div class="nexmoe-primary">
        <main id="pjax" class="fn__flex-1">
            
            <div class="nexmoe-post">
                <div class="nexmoe-post-cover">
                    <img src="https://b3logfile.com/bing/20200428.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100" alt="Flink的Watermark机制"
                         data-src="https://b3logfile.com/bing/20200428.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100" class=" ls-is-cached lazyloaded">
                    <h1>Flink的Watermark机制</h1>
                </div>
                <div class="nexmoe-post-meta">
                <span>
                    <i class="nexmoefont iconfont solo-calendarl"></i>2020年05月25日
                </span>

                    <span>
                    <i class="nexmoefont iconfont solo-heat"></i>
                    <b class="notb" data-uvstaturl="https://chaihaobo.github.io/articles/2020/05/25/1590412102084.html">0</b> °C
                </span>
                        <span>
                    <a class="nexmoefont iconfont solo-tag "
                       href="https://chaihaobo.github.io/tags/Flink">Flink</a>
                </span>

                </div>
                <article>
                    <div class="vditor-reset">
                        <h2 id="toc_h2_0">0x00 摘要</h2>
<p>对于Flink来说，Watermark是个很难绕过去的概念。本文将从整体的思路上来说，运用感性直觉的思考来帮大家梳理Watermark概念。</p>
<h2 id="toc_h2_1">0x01 问题</h2>
<p>关于Watermark，很容易产生几个问题</p>
<ul>
<li>Flink 流处理应用中，常见的处理需求/应对方案是什么?</li>
<li>Watermark究竟应该翻译成水印还是水位线？</li>
<li>Watermark本质是什么?</li>
<li>Watermark是如何解决问题?</li>
</ul>
<p>下面我们就来简要解答这些问题以给大家一个大致概念，在后文中，会再深入描述。</p>
<h3 id="toc_h3_2">问题1. Flink 流处理应用中常见的需求/方案是什么</h3>
<p><strong>聚合类的处理</strong> Flink可以每来一个消息就处理一次，但是有时我们需要做一些聚合类的处理，例如：在过去的1分钟内有多少用户点击了我们的网页。所以Flink引入了窗口概念。</p>
<p><strong>窗口</strong> 窗口的作用为了周期性的获取数据。就是把传入的原始数据流切分成多个buckets，所有计算都在单一的buckets中进行。窗口（window）就是从 Streaming 到 Batch 的一个桥梁。</p>
<p><strong>带来的问题</strong>：聚合类处理带来了新的问题，比如乱序/延迟。其解决方案就是 Watermark / allowLateNess / sideOutPut 这一组合拳。</p>
<p><strong>Watermark</strong> 的作用是防止 数据乱序 / 指定时间内获取不到全部数据。</p>
<p><strong>allowLateNess</strong> 是将窗口关闭时间再延迟一段时间。</p>
<p>**sideOutPut **是最后兜底操作，当指定窗口已经彻底关闭后，就会把所有过期延迟数据放到侧输出流，让用户决定如何处理。</p>
<p>总结起来就是说</p>
<pre><code class="language-java">Windows -----&gt; Watermark -----&gt; allowLateNess -----&gt; sideOutPut 
  
用Windows把流数据分块处理，用Watermark确定什么时候不再等待更早的数据/触发窗口进行计算，用allowLateNess 将窗口关闭时间再延迟一段时间。用sideOutPut 最后兜底把数据导出到其他地方。
</code></pre>
<h3 id="toc_h3_3">问题2. Watermark应该翻译成水位线</h3>
<p>我最初看的一篇文章中把Watermark翻译成“<em>水印</em>”。我当时比较晕。因为按说名字一定能够反应事物本质。但是我怎么也脑补不出这个”<em>水印</em>“的本质。</p>
<p>继续看文章内容，越来越觉得这个应该翻译成“水位线”。于是查了查，确实英文有如下翻译：high-water mark 高水位线(海水或洪水所达到的最高水位)。</p>
<p>后来逐渐看到其他文章中也有翻译成水位线，我才放心下来，终于不会出现第二个“套接字”这样神奇的翻译了。</p>
<h3 id="toc_h3_4">问题3. Watermark本质是什么</h3>
<p>Watermarks是基于已经收集的消息来估算是否还有消息未到达，本质上是一个时间戳。时间戳反映的是事件发生的时间，而不是事件处理的时间。</p>
<p>这个从Flink的源码就能看出来，唯一有意义的成员变量就是 timestamp。</p>
<pre><code class="language-java">public final class Watermark extends StreamElement {
  /*The watermark that signifies end-of-event-time. */
  public static final Watermark MAX_WATERMARK = new Watermark(Long.MAX_VALUE);
  /* The timestamp of the watermark in milliseconds. */
  private final long timestamp;
  /* Creates a new watermark with the given timestamp in milliseconds.*/
  public Watermarklong timestamp) {
    this.timestamp = timestamp;
  }
  /*Returns the timestamp associated with this {@link Watermark} in milliseconds.**/
  public long getTimestamp() {
    return timestamp;
  }
}
</code></pre>
<h3 id="toc_h3_5">问题4. Watermark如何解决问题</h3>
<p>Watermark是一种告诉Flink一个消息延迟多少的方式。它定义了什么时候不再等待更早的数据。</p>
<p>可以把Watermarks理解为一个水位线，这个Watermarks在不断的变化。Watermark实际上作为数据流的一部分随数据流流动。</p>
<p>当Flink中的运算符接收到Watermarks时，它明白早于该时间的消息已经完全抵达计算引擎，即假设不会再有时间小于水位线的事件到达。</p>
<p>这个假设是触发窗口计算的基础，只有水位线越过窗口对应的结束时间，窗口才会关闭和进行计算。</p>
<h2 id="toc_h2_6">0x02 背景概念</h2>
<h3 id="toc_h3_7">流处理</h3>
<p>流处理，最本质的是在处理数据的时候，接受一条处理一条数据。</p>
<p>批处理，则是累积数据到一定程度在处理。这是他们本质的区别。</p>
<p>在设计上Flink认为数据是流式的，批处理只是流处理的特例。同时对数据分为有界数据和无界数据。</p>
<ul>
<li>有界数据对应批处理，API对应Dateset。</li>
<li>无界数据对应流处理，API对应DataStream。</li>
</ul>
<h3 id="toc_h3_8">乱序（out-of-order）</h3>
<p>什么是乱序呢？可以理解为数据到达的顺序和其实际产生时间的排序不一致。导致这的原因有很多，比如延迟，消息积压，重试等等。</p>
<p>我们知道，流处理从事件产生，到流经source，再到operator，中间是有一个过程和时间的。虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、背压等原因，导致乱序的产生（out-of-order或者说late element）。</p>
<p>比如：</p>
<pre><code class="language-java">某数据源中的某些数据由于某种原因(如：网络原因，外部存储自身原因)会有5秒的延时，
也就是在实际时间的第1秒产生的数据有可能在第5秒中产生的数据之后到来(比如到Window处理节点)。

有1~10个事件。
乱序到达的序列是：2,3,4,5,1,6,3,8,9,10,7
</code></pre>
<h2 id="toc_h2_9">0x03 Flink中的窗口概念</h2>
<h3 id="toc_h3_10">窗口</h3>
<p>对于Flink，如果来一条消息计算一条，这样是可以的，但是这样计算是非常频繁而且消耗资源，如果想做一些统计这是不可能的。所以对于Spark和Flink都产生了窗口计算。</p>
<p>比如 是因为我们想看到过去一分钟，过去半小时的访问数据，这时候我们就需要窗口。</p>
<p><strong>Window</strong>：Window是处理无界流的关键，Windows将流拆分为一个个有限大小的 <code>buckets</code>，可以可以在每一个 <code>buckets</code>中进行计算。</p>
<p><strong>start_time,end_time</strong>：当Window时时间窗口的时候，每个window都会有一个开始时间和结束时间（前开后闭），这个时间是系统时间。</p>
<h3 id="toc_h3_11">窗口生命周期</h3>
<p>简而言之，只要属于此窗口的第一个元素到达，就会创建一个窗口，当时间（事件或处理时间）超过其结束时间戳加上用户指定的允许延迟时，窗口将被完全删除。</p>
<p>例如:</p>
<pre><code class="language-java">使用基于事件时间的窗口策略，每5分钟创建一个不重叠（或翻滚）的窗口并允许延迟1分钟。
  
假定目前是12:00。

当具有落入该间隔的时间戳的第一个元素到达时，Flink将为12:00到12:05之间的间隔创建一个新窗口，当水位线（watermark）到12:06时间戳时将删除它。
</code></pre>
<p>窗口有如下组件：</p>
<p>**Window Assigner：**用来决定某个元素被分配到哪个/哪些窗口中去。</p>
<p>**Trigger：**触发器。决定了一个窗口何时能够被计算或清除。触发策略可能类似于“当窗口中的元素数量大于4”时，或“当水位线通过窗口结束时”。</p>
<p>**Evictor：**它可以在 触发器触发后 &amp; 应用函数之前和/或之后 从窗口中删除元素。</p>
<p>窗口还拥有函数，比如 ProcessWindowFunction，ReduceFunction，AggregateFunction或FoldFunction。该函数将包含要应用于窗口内容的计算，而触发器指定窗口被认为准备好应用该函数的条件。</p>
<h3 id="toc_h3_12">Keyed vs Non-Keyed Windows</h3>
<p>在定义窗口之前,要指定的第一件事是流是否需要Keyed，使用keyBy（...）将无界流分成逻辑的keyed stream。 如果未调用keyBy（...），则表示流不是keyed stream。</p>
<ul>
<li>对于Keyed流，可以将传入事件的任何属性用作key。 拥有Keyed stream将允许窗口计算由多个任务并行执行，因为每个逻辑Keyed流可以独立于其余任务进行处理。 相同Key的所有元素将被发送到同一个任务。</li>
<li>在Non-Keyed流的情况下，原始流将不会被分成多个逻辑流，并且所有窗口逻辑将由单个任务执行，即并行性为1。</li>
</ul>
<h3 id="toc_h3_13">窗口分类</h3>
<p>窗口分类可以分成：翻滚窗口（Tumbling Window，无重叠），滚动窗口（Sliding Window，有重叠），和会话窗口，（Session Window，活动间隙）</p>
<p><strong>滚动窗口</strong><br>
滚动窗口分配器将每个元素分配给固定窗口大小的窗口。滚动窗口大小固定的并且不重叠。例如，如果指定大小为5分钟的滚动窗口，则将执行当前窗口，并且每五分钟将启动一个新窗口。</p>
<p><strong>滑动窗口</strong></p>
<p>滑动窗口与滚动窗口的区别就是滑动窗口有重复的计算部分。</p>
<p>滑动窗口分配器将每个元素分配给固定窗口大小的窗口。类似于滚动窗口分配器，窗口的大小由窗口大小参数配置。另外一个窗口滑动参数控制滑动窗口的启动频率(how frequently a sliding window is started)。因此，如果滑动大小小于窗口大小，滑动窗可以重叠。在这种情况下，元素被分配到多个窗口。</p>
<p>例如，你可以使用窗口大小为10分钟的窗口，滑动大小为5分钟。这样，每5分钟会生成一个窗口，包含最后10分钟内到达的事件。</p>
<p><strong>会话窗口</strong><br>
会话窗口分配器通过活动会话分组元素。与滚动窗口和滑动窗口相比，会话窗口不会重叠，也没有固定的开始和结束时间。相反，当会话窗口在一段时间内没有接收到元素时会关闭。</p>
<p>例如，不活动的间隙时。会话窗口分配器配置会话间隙，定义所需的不活动时间长度(defines how long is the required period of inactivity)。当此时间段到期时，当前会话关闭，后续元素被分配到新的会话窗口。</p>
<h2 id="toc_h2_14">0x04 Flink中的时间概念</h2>
<p>Flink在流处理程序支持不同的时间概念。分别为Event Time/Processing Time/Ingestion Time，也就是事件时间、处理时间、提取时间。</p>
<p>从时间序列角度来说，发生的先后顺序是：</p>
<pre><code class="language-java">事件时间（Event Time）----&gt; 提取时间（Ingestion Time）----&gt; 处理时间（Processing Time）
</code></pre>
<ul>
<li>Event Time 是事件在现实世界中发生的时间，它通常由事件中的时间戳描述。</li>
<li>Ingestion Time 是数据进入Apache Flink流处理系统的时间，也就是Flink读取数据源时间。</li>
<li>Processing Time 是数据流入到具体某个算子 (消息被计算处理) 时候相应的系统时间。也就是Flink程序处理该事件时当前系统时间。</li>
</ul>
<p>但是我们讲解时，会从后往前讲解，把最重要的Event Time放在最后。</p>
<h3 id="toc_h3_15">处理时间</h3>
<p>是数据流入到具体某个算子时候相应的系统时间。</p>
<p>这个系统时间指的是执行相应操作的机器的系统时间。当一个流程序通过处理时间来运行时，所有基于时间的操作(如: 时间窗口)将使用各自操作所在的物理机的系统时间。</p>
<p>ProcessingTime 有最好的性能和最低的延迟。但在分布式计算环境或者异步环境中，ProcessingTime具有不确定性，相同数据流多次运行有可能产生不同的计算结果。因为它容易受到从记录到达系统的速度（例如从消息队列）到记录在系统内的operator之间流动的速度的影响（停电，调度或其他）。</p>
<h3 id="toc_h3_16">提取时间</h3>
<p>IngestionTime是数据进入Apache Flink框架的时间，是在Source Operator中设置的。每个记录将源的当前时间作为时间戳，并且后续基于时间的操作（如时间窗口）引用该时间戳。</p>
<p>提取时间在概念上位于事件时间和处理时间之间。与处理时间相比，它稍早一些。IngestionTime与ProcessingTime相比可以提供更可预测的结果，因为IngestionTime的时间戳比较稳定(在源处只记录一次)，所以同一数据在流经不同窗口操作时将使用相同的时间戳，而对于ProcessingTime同一数据在流经不同窗口算子会有不同的处理时间戳。</p>
<p>与事件时间相比，提取时间程序无法处理任何无序事件或后期数据，但程序不必指定如何生成水位线。</p>
<p>在内部，提取时间与事件时间非常相似，但具有自动时间戳分配和自动水位线生成功能。</p>
<h3 id="toc_h3_17">事件时间</h3>
<p>事件时间就是事件在真实世界的发生时间，即每个事件在产生它的设备上发生的时间（当地时间）。比如一个点击事件的时间发生时间，是用户点击操作所在的手机或电脑的时间。</p>
<p>在进入Apache Flink框架之前EventTime通常要嵌入到记录中，并且EventTime也可以从记录中提取出来。在实际的网上购物订单等业务场景中，大多会使用EventTime来进行数据计算。</p>
<p>基于事件时间处理的强大之处在于即使在乱序事件，延迟事件，历史数据以及从备份或持久化日志中的重复数据也能获得正确的结果。对于事件时间，时间的进度取决于数据，而不是任何时钟。</p>
<p>事件时间程序必须指定如何生成事件时间的 <code>Watermarks</code>，这是表示事件时间进度的机制。</p>
<p>现在假设我们正在创建一个排序的数据流。这意味着应用程序处理流中的乱序到达的事件，并生成同样事件但按时间戳（事件时间）排序的新数据流。</p>
<p>比如:</p>
<pre><code>有1~10个事件。
乱序到达的序列是：1,2,4,5,6,3,8,9,10,7
经过按 事件时间 处理后的序列是：1,2,3,4,5,6,7,8,9,10
</code></pre>
<p>为了处理事件时间，Flink需要知道事件的时间戳，这意味着流中的每条数据都需要分配其事件时间戳。这通常通过提取每条数据中的固定字段来完成时间戳的获取。</p>
<h3 id="toc_h3_18">设定时间特性</h3>
<p>Flink DataStream 程序的第一部分通常是设置基本时间特性。 该设置定义了数据流源的行为方式（例如：它们是否将分配时间戳），以及像 **KeyedStream.timeWindow(Time.seconds(30)) ** 这样的窗口操作应该使用上面哪种时间概念。</p>
<p>比如：</p>
<pre><code class="language-java">final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime);
</code></pre>
<h2 id="toc_h2_19">0x05 Watermark</h2>
<p>前文讲到了事件时间，这个真实发生的时间是我们业务在实时处理程序中非常关心的。在一个理想的情况下，事件时间处理将产生完全一致和确定的结果，无论事件何时到达或其排序。但是在现实中，消息不在是按照顺序发送，产生了乱序，这时候该怎么处理？</p>
<p>Watermark是Apache Flink为了处理EventTime 窗口计算提出的一种机制,本质上也是一种时间戳。watermark是用于处理乱序事件或延迟数据的，这通常用watermark机制结合window来实现（Watermarks用来触发window窗口计算）。</p>
<p>比如对于late element，我们不能无限期的等下去，必须要有个机制来保证一个特定的时间后，必须触发window去进行计算了。这个特别的机制，就是watermark。 可以把Watermark看作是一种告诉Flink一个消息延迟多少的方式。定义了什么时候不再等待更早的数据。</p>
<h3 id="toc_h3_20">1. 窗口触发条件</h3>
<p>上面谈到了对数据乱序问题的处理机制是watermark+window，那么window什么时候该被触发呢？</p>
<p>基于Event Time的事件处理，Flink默认的事件触发条件为：</p>
<p><strong>对于out-of-order及正常的数据而言</strong></p>
<ul>
<li>watermark的时间戳 &gt; = window endTime</li>
<li>在 [window_start_time,window_end_time] 中有数据存在。</li>
</ul>
<p><strong>对于late element太多的数据而言</strong></p>
<ul>
<li>Event Time &gt; watermark的时间戳</li>
</ul>
<p>WaterMark相当于一个EndLine，一旦Watermarks大于了某个window的end_time，就意味着windows_end_time时间和WaterMark时间相同的窗口开始计算执行了。</p>
<p>就是说，我们根据一定规则，计算出Watermarks，并且设置一些延迟，给迟到的数据一些机会，也就是说正常来讲，对于迟到的数据，我只等你一段时间，再不来就没有机会了。</p>
<p>WaterMark时间可以用Flink系统现实时间，也可以用处理数据所携带的Event time。</p>
<p>使用Flink系统现实时间，在并行和多线程中需要注意的问题较少，因为都是以现实时间为标准。</p>
<p>如果使用处理数据所携带的Event time作为WaterMark时间，需要注意两点：</p>
<ul>
<li>因为数据到达并不是循序的，注意保存一个当前最大时间戳作为WaterMark时间</li>
<li>并行同步问题</li>
</ul>
<h3 id="toc_h3_21">2. WaterMark设定方法</h3>
<h4 id="toc_h4_22">标点水位线(Punctuated Watermark)</h4>
<p>标点水位线（Punctuated Watermark）通过数据流中某些特殊标记事件来触发新水位线的生成。这种方式下窗口的触发与时间无关，而是决定于何时收到标记事件。</p>
<p>在实际的生产中Punctuated方式在TPS很高的场景下会产生大量的Watermark在一定程度上对下游算子造成压力，所以只有在实时性要求非常高的场景才会选择Punctuated的方式进行Watermark的生成。</p>
<h4 id="toc_h4_23">定期水位线(Periodic Watermark)</h4>
<p>周期性的（允许一定时间间隔或者达到一定的记录条数）产生一个Watermark。水位线提升的时间间隔是由用户设置的，在两次水位线提升时隔内会有一部分消息流入，用户可以根据这部分数据来计算出新的水位线。</p>
<p>在实际的生产中Periodic的方式必须结合时间和积累条数两个维度继续周期性产生Watermark，否则在极端情况下会有很大的延时。</p>
<p>举个例子，最简单的水位线算法就是取目前为止最大的事件时间，然而这种方式比较暴力，对乱序事件的容忍程度比较低，容易出现大量迟到事件。</p>
<h3 id="toc_h3_24">3. 迟到事件</h3>
<p>虽说水位线表明着早于它的事件不应该再出现，但是上如上文所讲，接收到水位线以前的的消息是不可避免的，这就是所谓的迟到事件。实际上迟到事件是乱序事件的特例，和一般乱序事件不同的是它们的乱序程度超出了水位线的预计，导致窗口在它们到达之前已经关闭。</p>
<p>迟到事件出现时窗口已经关闭并产出了计算结果，因此处理的方法有3种：</p>
<ul>
<li>重新激活已经关闭的窗口并重新计算以修正结果。</li>
<li>将迟到事件收集起来另外处理。</li>
<li>将迟到事件视为错误消息并丢弃。</li>
</ul>
<p>Flink 默认的处理方式是第3种直接丢弃，其他两种方式分别使用 <code>Side Output</code>和 <code>Allowed Lateness</code>。</p>
<p><code>Side Output</code>机制可以将迟到事件单独放入一个数据流分支，这会作为 window 计算结果的副产品，以便用户获取并对其进行特殊处理。</p>
<p><code>Allowed Lateness</code>机制允许用户设置一个允许的最大迟到时长。Flink 会在窗口关闭后一直保存窗口的状态直至超过允许迟到时长，这期间的迟到事件不会被丢弃，而是默认会触发窗口重新计算。因为保存窗口状态需要额外内存，并且如果窗口计算使用了 <code>ProcessWindowFunction</code> API 还可能使得每个迟到事件触发一次窗口的全量计算，代价比较大，所以允许迟到时长不宜设得太长，迟到事件也不宜过多，否则应该考虑降低水位线提高的速度或者调整算法。</p>
<p>这里总结机制为：</p>
<ul>
<li>窗口window 的作用是为了周期性的获取数据。</li>
<li>watermark的作用是防止数据出现乱序(经常)，事件时间内获取不到指定的全部数据，而做的一种保险方法。</li>
<li>allowLateNess是将窗口关闭时间再延迟一段时间。</li>
<li>sideOutPut是最后兜底操作，所有过期延迟数据，指定窗口已经彻底关闭了，就会把数据放到侧输出流。</li>
</ul>
<h3 id="toc_h3_25">4. 实例</h3>
<h4 id="toc_h4_26">采用系统时间做Watermark</h4>
<p>我们将水位线设置为当前系统时间间-5秒。</p>
<pre><code class="language-scala">override def getCurrentWatermark(): Watermark = {     
	new Watermark(System.currentTimeMillis - 5000) 
}
</code></pre>
<p>通常最好保持接收到的最大时间戳，并创建具有最大预期延迟的水位线，而不是从当前系统时间减去。</p>
<h4 id="toc_h4_27">采用Event Time做watermark</h4>
<p>例如基于Event Time的数据，自身都包含一个类型为timestamp的字段，假设叫做rowtime，例如1543903383（2018-12-04 14:03:03），定义一个基于rowtime列，策略为偏移3s的watermark，这条数据的水位线时间戳则是：</p>
<pre><code>1543903383-3000 = 1543900383（2018-12-04 14:03:00）
</code></pre>
<p>该条数据的水位线时间含义：timestamp小于1543900383（2018-12-04 14:03:00）的数据，都已经到达了。</p>
<pre><code class="language-scala">class BoundedOutOfOrdernessGenerator extends AssignerWithPeriodicWatermarks[MyEvent] {
    val maxOutOfOrderness = 3000L; // 3 seconds
    var currentMaxTimestamp: Long;
    override def extractTimestamp(element: MyEvent, previousElementTimestamp: Long): Long = {
        val timestamp = element.getCreationTime()
        currentMaxTimestamp = max(timestamp, currentMaxTimestamp)
        timestamp;
    }
    override def getCurrentWatermark(): Watermark = {
        // return the watermark as current highest timestamp minus the out-of-orderness bound
        new Watermark(currentMaxTimestamp - maxOutOfOrderness);
    }
}
</code></pre>
<h4 id="toc_h4_28">看看如何触发窗口</h4>
<p><strong>我们明白了窗口的触发机制，这里我们添加了水位线，到底是个怎么个情况？我们来看下面</strong></p>
<blockquote>
<p>假如我们设置10s的时间窗口（window），那么010s，1020s都是一个窗口，以0~10s为例，0为start-time，10为end-time。假如有4个数据的event-time分别是8(A),12.5(B),9(C),13.5(D)，我们设置Watermarks为当前所有到达数据event-time的最大值减去延迟值3.5秒</p>
<p>当A到达的时候，Watermarks为 <code>max{8}-3.5=8-3.5 = 4.5 &lt; 10</code>,不会触发计算<br>
当B到达的时候，Watermarks为 <code>max(12.5,8)-3.5=12.5-3.5 = 9 &lt; 10</code>,不会触发计算<br>
当C到达的时候，Watermarks为 <code>max(12.5,8,9)-3.5=12.5-3.5 = 9 &lt; 10</code>,不会触发计算<br>
当D到达的时候，Watermarks为 <code>max(13.5,12.5,8,9)-3.5=13.5-3.5 = 10 = 10</code>,触发计算<br>
触发计算的时候，会将A，C（因为他们都小于10）都计算进去，其中C是迟到的。</p>
<p>max这个很关键，就是当前窗口内，所有事件的最大事件。</p>
<p>这里的延迟3.5s是我们假设一个数据到达的时候，比他早3.5s的数据肯定也都到达了，这个是需要根据经验推算。假设加入D到达以后有到达了一个E,event-time=6，但是由于0~10的时间窗口已经开始计算了，所以E就丢了。</p>
<p>从这里上面E的丢失说明，水位线也不是万能的，但是如果根据我们自己的生产经验+侧道输出等方案，可以做到数据不丢失。</p>
</blockquote>
<h2 id="toc_h2_29">0x06 Flink源码</h2>
<h3 id="toc_h3_30">数据结构定义</h3>
<p>在Flink DataStream中流动着不同的元素，统称为StreamElement，StreamElement可以是StreamRecord、Watermark、StreamStatus、LatencyMarker中任何一种类型。</p>
<h4 id="toc_h4_31">StreamElement</h4>
<p><strong>StreamElement</strong>是一个抽象类(是Flink 承载消息的基类)，其他四种类型继承StreamElement。</p>
<pre><code class="language-java">public abstract class StreamElement {
  //判断是否是Watermark
  public final boolean isWatermark() {
    return getClass() == Watermark.class;
  }
  //判断是否为StreamStatus
  public final boolean isStreamStatus() {
    return getClass() == StreamStatus.class;
  }
  //判断是否为StreamRecord
  public final boolean isRecord() {
    return getClass() == StreamRecord.class;
  }
  //判断是否为LatencyMarker
  public final boolean isLatencyMarker() {
    return getClass() == LatencyMarker.class;
  }
  //转换为StreamRecord
  public final &lt;E&gt; StreamRecord&lt;E&gt; asRecord() {
    return (StreamRecord&lt;E&gt;) this;
  }
  //转换为Watermark
  public final Watermark asWatermark() {
    return (Watermark) this;
  }
  //转换为StreamStatus
  public final StreamStatus asStreamStatus() {
    return (StreamStatus) this;
  }
  //转换为LatencyMarker
  public final LatencyMarker asLatencyMarker() {
    return (LatencyMarker) this;
  }
}
</code></pre>
<h4 id="toc_h4_32">Watermark</h4>
<p><strong>Watermark</strong>继承了StreamElement。Watermark 是和事件一个级别的抽象，其内部包含一个成员变量时间戳timestamp，标识当前数据的时间进度。Watermark实际上作为数据流的一部分随数据流流动。</p>
<pre><code class="language-java">@PublicEvolving
public final class Watermark extends StreamElement {
  /*The watermark that signifies end-of-event-time. */
  public static final Watermark MAX_WATERMARK = new Watermark(Long.MAX_VALUE);
  /* The timestamp of the watermark in milliseconds. */
  private final long timestamp;
  /* Creates a new watermark with the given timestamp in milliseconds.*/
  public Watermarklong timestamp) {
	this.timestamp = timestamp;
  }
  /*Returns the timestamp associated with this {@link Watermark} in milliseconds.**/
  public long getTimestamp() {
    return timestamp;
  }
}
</code></pre>
<h3 id="toc_h3_33">Flink如何生成&amp;处理Watermark</h3>
<p>在实际使用中大多数情况下会选择周期性生成方式也就是AssignerWithPeriodicWatermarks方式.</p>
<pre><code class="language-scala">//指定为evenTime时间语义
env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)
//生成watermark的周期
env.getConfig.setAutoWatermarkInterval(watermarkInterval)
//指定方式
dataStream.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor[Element](Time.seconds(allowDealy)) {
   override def extractTimestamp(element: Element): Long = element.dT
  })
</code></pre>
<p>BoundedOutOfOrdernessTimestampExtractor 是Flink内置提供的允许乱序最大延时的watermark生成方式，只需要重写其extractTimestamp方法即可。</p>
<p>assignTimestampsAndWatermarks 可以理解为是一个算子转换操作，等同于map/window一样理解，可以为其设置并行度、名称，也是一个transformation/operator，</p>
<pre><code class="language-java">public SingleOutputStreamOperator&lt;T&gt; assignTimestampsAndWatermarks(
		AssignerWithPeriodicWatermarks&lt;T&gt; timestampAndWatermarkAssigner) {

	// match parallelism to input, otherwise dop=1 sources could lead to some strange
	// behaviour: the watermark will creep along very slowly because the elements
	// from the source go to each extraction operator round robin.
	final int inputParallelism = getTransformation().getParallelism();
	final AssignerWithPeriodicWatermarks&lt;T&gt; cleanedAssigner = clean(timestampAndWatermarkAssigner);

	TimestampsAndPeriodicWatermarksOperator&lt;T&gt; operator =
			new TimestampsAndPeriodicWatermarksOperator&lt;&gt;(cleanedAssigner);

	return transform("Timestamps/Watermarks", getTransformation().getOutputType(), operator)
			.setParallelism(inputParallelism);
}
</code></pre>
<p>其使用的StreamOperator类型TimestampsAndPeriodicWatermarksOperator，继承了AbstractUdfStreamOperator，实现了OneInputStreamOperator接口与ProcessingTimeCallback接口，</p>
<p><strong>TimestampsAndPeriodicWatermarksOperator</strong>。</p>
<pre><code class="language-java">/**
 * A stream operator that extracts timestamps from stream elements and
 * generates periodic watermarks.
 *
 * @param &lt;T&gt; The type of the input elements
 */
public class TimestampsAndPeriodicWatermarksOperator&lt;T&gt;
		extends AbstractUdfStreamOperator&lt;T, AssignerWithPeriodicWatermarks&lt;T&gt;&gt;
		implements OneInputStreamOperator&lt;T, T&gt;, ProcessingTimeCallback {

	private static final long serialVersionUID = 1L;
	private transient long watermarkInterval;
	private transient long currentWatermark;

	public TimestampsAndPeriodicWatermarksOperator(AssignerWithPeriodicWatermarks&lt;T&gt; assigner) {
		super(assigner);
		this.chainingStrategy = ChainingStrategy.ALWAYS;
	}

	@Override
	public void open() throws Exception {
		super.open();
        //初始化默认当前watermark
		currentWatermark = Long.MIN_VALUE;
        //生成watermark周期时间配置
		watermarkInterval = getExecutionConfig().getAutoWatermarkInterval();
        //注册定时其配置
		if (watermarkInterval &gt; 0) {
			long now = getProcessingTimeService().getCurrentProcessingTime();
            //注册一个watermarkInterval后触发的定时器，传入回调参数是this，也就是会调用当前对象的onProcessingTime方法
			getProcessingTimeService().registerTimer(now + watermarkInterval, this);
		}
	}

	@Override
	public void processElement(StreamRecord&lt;T&gt; element) throws Exception {
        //提取当前的事件时间
		final long newTimestamp = userFunction.extractTimestamp(element.getValue(),
				element.hasTimestamp() ? element.getTimestamp() : Long.MIN_VALUE);
        //保存当前最大的事件时间。
		output.collect(element.replace(element.getValue(), newTimestamp));
	}

	@Override
	public void onProcessingTime(long timestamp) throws Exception {
        //此方法表示的就是定时回调的方法，将符合要求的watermark发送出去并且注册下一个定时器。
		// register next timer
		Watermark newWatermark = userFunction.getCurrentWatermark();
        //当新的watermark大于当前的watermark
		if (newWatermark != null &amp;&amp; newWatermark.getTimestamp() &gt; currentWatermark) {
			currentWatermark = newWatermark.getTimestamp();
            //将符合要求的watermark发送出去
			// emit watermark
			output.emitWatermark(newWatermark);
		}
        //注册下一次触发时间
		long now = getProcessingTimeService().getCurrentProcessingTime();
		getProcessingTimeService().registerTimer(now + watermarkInterval, this);
	}

	/**
	 * Override the base implementation to completely ignore watermarks propagated from
	 * upstream (we rely only on the {@link AssignerWithPeriodicWatermarks} to emit
	 * watermarks from here).
	 */
	@Override
	public void processWatermark(Watermark mark) throws Exception {
        //用来处理上游发送过来的watermark，可以认为不做任何处理，下游的watermark只与其上游最近的生成方式相关。
		// if we receive a Long.MAX_VALUE watermark we forward it since it is used
		// to signal the end of input and to not block watermark progress downstream
		if (mark.getTimestamp() == Long.MAX_VALUE &amp;&amp; currentWatermark != Long.MAX_VALUE) {
			currentWatermark = Long.MAX_VALUE;
			output.emitWatermark(mark);
		}
	}

	@Override
	public void close() throws Exception {
		super.close();

		// emit a final watermark
		Watermark newWatermark = userFunction.getCurrentWatermark();
		if (newWatermark != null &amp;&amp; newWatermark.getTimestamp() &gt; currentWatermark) {
			currentWatermark = newWatermark.getTimestamp();
			// emit watermark
			output.emitWatermark(newWatermark);
		}
	}
}
</code></pre>
<h3 id="toc_h3_34">Flink如何处理迟到数据</h3>
<p>这里我们使用 Side Output机制来说明。<code>Side Output</code>机制可以将迟到事件单独放入一个数据流分支，这会作为 window 计算结果的副产品，以便用户获取并对其进行特殊处理。</p>
<h4 id="toc_h4_35">生成新的Watermark</h4>
<p>Flink会替换StreamRecord 对象中的Timestamp，如果 根据当前事件的Timestamp 生成的Watermark 大于上一次的Watermark，就发出新的Watermark。</p>
<p>具体代码在 TimestampsAndPunctuatedWatermarksOperator.processElement。</p>
<pre><code class="language-java">@Override
public void processElement(StreamRecord&lt;T&gt; element) throws Exception {
	final T value = element.getValue();
    // 调用 用户实现的 extractTimestamp 获取新的Timestamp
	final long newTimestamp = userFunction.extractTimestamp(value,
			element.hasTimestamp() ? element.getTimestamp() : Long.MIN_VALUE);
    // 用新Timestamp 替换StreamRecord中的旧Timestamp
	output.collect(element.replace(element.getValue(), newTimestamp));
    // 调用 用户实现的 checkAndGetNextWatermark 方法获取下一个Watermark
	final Watermark nextWatermark = userFunction.checkAndGetNextWatermark(value, newTimestamp);
    // 如果下一个Watermark 大于当前Watermark，就发出新的Watermark
	if (nextWatermark != null &amp;&amp; nextWatermark.getTimestamp() &gt; currentWatermark) {
		currentWatermark = nextWatermark.getTimestamp();
		output.emitWatermark(nextWatermark);
	}
}
</code></pre>
<h4 id="toc_h4_36">处理迟到数据</h4>
<p>首先，判断是否是迟到数据。</p>
<pre><code class="language-java">@Override
public void processElement(StreamRecord&lt;IN&gt; element) throws Exception {
			for (W window: elementWindows) {
				// drop if the window is already late
                // 如果窗口已经迟到了，则处理下一条数据
				if (isWindowLate(window)) {
					continue;
				}   
            }
    ......
}

/**
 Returns {@code true} if the watermark is after the end timestamp plus the allowed lateness of the given window.
 */
protected boolean isWindowLate(W window) {
    // 当前机制是 事件时间 &amp;&amp; 窗口元素的最大时间戳 + 允许迟到时间 &lt;= 当前水位线 的时候为true（即当前窗口元素迟到了）
	return (windowAssigner.isEventTime() &amp;&amp; (cleanupTime(window) &lt;= internalTimerService.currentWatermark()));
}

/**
 * Returns the cleanup time for a window, which is
 * {@code window.maxTimestamp + allowedLateness}. In
 * case this leads to a value greater than {@link Long#MAX_VALUE}
 * then a cleanup time of {@link Long#MAX_VALUE} is
 * returned.
 *
 * @param window the window whose cleanup time we are computing.
 */
private long cleanupTime(W window) {
	if (windowAssigner.isEventTime()) {
		long cleanupTime = window.maxTimestamp() + allowedLateness;
    //返回窗口的 cleanup 时间 : 窗口元素的最大时间戳 + 允许延迟的时间
		return cleanupTime &gt;= window.maxTimestamp() ? cleanupTime : Long.MAX_VALUE;
	} else {
		return window.maxTimestamp();
	}
}
</code></pre>
<p>其次，处理迟到数据的具体代码在WindowOperator.processElement 方法的最后一段。这里就是旁路输出。</p>
<pre><code class="language-java">@Override
public void processElement(StreamRecord&lt;IN&gt; element) throws Exception {
  
    ......
    // 其他操作
    ......
  
    // side output input event if element not handled by any window  late arriving tag has been set
    // 如果没有window处理过这条数据，isSkippedElement = true，如果上面判断为迟到数据，isSkippedElement = false
    // windowAssigner is event time and current timestamp + allowed lateness no less than element timestamp
    if (isSkippedElement &amp;&amp; isElementLate(element)) {
      if (lateDataOutputTag != null){
          //旁路输出
          //这就是我们之前提到的，Flink 的 Side Output 机制可以将迟到事件单独放入一个数据流分支，这会作为 window 计算结果的副产品，以便用户获取并对其进行特殊处理。
        sideOutput(element);
      } else {
        this.numLateRecordsDropped.inc();
      }
    }
}

/**
 * Decide if a record is currently late, based on current watermark and allowed lateness.
 * 当前机制是 事件时间 &amp;&amp; (元素时间戳 + 允许延迟的时间) &lt;= 当前水位线
 * @param element The element to check
 * @return The element for which should be considered when sideoutputs
 */
protected boolean isElementLate(StreamRecord&lt;IN&gt; element){
	return (windowAssigner.isEventTime()) &amp;&amp;
		(element.getTimestamp() + allowedLateness &lt;= internalTimerService.currentWatermark());
}

/**
 * Write skipped late arriving element to SideOutput.
 * // 把数据输出到旁路，供用户决定如何处理。
 * @param element skipped late arriving element to side output
 */
protected void sideOutput(StreamRecord&lt;IN&gt; element){
    output.collect(lateDataOutputTag, element);
}
</code></pre>
                    </div>
                </article>
                    <div class="nexmoe-post-copyright">
                        <i class="mdui-list-item-icon iconfont solo-about2"></i>
                        <hr>

标题：Flink的Watermark机制<br>
作者：<a href="https://chaihaobo.github.io" target="_blank">chaihaobo</a><br>
地址：<a href="https://chaihaobo.github.io/articles/2020/05/25/1590412102084.html" target="_blank">https://chaihaobo.github.io/articles/2020/05/25/1590412102084.html</a><br>
概述：坐标南京,研发工程师
<!-- 签名档内可使用 HTML、JavaScript -->
<br>
                    </div>
            </div>
            <div class="post__toc">
<ul class="article__toc">
        <li class="toc__h2">
            <a href="#toc_h2_0">0x00 摘要</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_1">0x01 问题</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_2">问题1. Flink 流处理应用中常见的需求/方案是什么</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_3">问题2. Watermark应该翻译成水位线</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_4">问题3. Watermark本质是什么</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_5">问题4. Watermark如何解决问题</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_6">0x02 背景概念</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_7">流处理</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_8">乱序（out-of-order）</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_9">0x03 Flink中的窗口概念</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_10">窗口</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_11">窗口生命周期</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_12">Keyed vs Non-Keyed Windows</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_13">窗口分类</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_14">0x04 Flink中的时间概念</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_15">处理时间</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_16">提取时间</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_17">事件时间</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_18">设定时间特性</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_19">0x05 Watermark</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_20">1. 窗口触发条件</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_21">2. WaterMark设定方法</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_22">标点水位线(Punctuated Watermark)</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_23">定期水位线(Periodic Watermark)</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_24">3. 迟到事件</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_25">4. 实例</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_26">采用系统时间做Watermark</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_27">采用Event Time做watermark</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_28">看看如何触发窗口</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_29">0x06 Flink源码</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_30">数据结构定义</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_31">StreamElement</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_32">Watermark</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_33">Flink如何生成&处理Watermark</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_34">Flink如何处理迟到数据</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_35">生成新的Watermark</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_36">处理迟到数据</a>
        </li>
</ul>            </div>
                <div id="b3logsolocomments"></div>
                <div id="vcomment" style="padding: 30px 0;" data-name="chaihaobo" data-postId="1590412102084"></div>

            
        </main>

        <div class="back-to-top iconfont solo-gotop" onclick="Util.goTop()"></div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script type="text/javascript" src="https://chaihaobo.github.io/js/common.min.js?1590205324215"
        charset="utf-8"></script>
    <script type="text/javascript" src="https://chaihaobo.github.io/skins/nexmoe/js/canvas.js?1590205324215"
            charset="utf-8"></script>

<script src="https://chaihaobo.github.io/skins/nexmoe/js/app.js?1590205324215"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>
<script type="text/javascript" src="https://chaihaobo.github.io/js/common.min.js?1590205324215"
        charset="utf-8"></script>
<script type="text/javascript" src="https://chaihaobo.github.io/skins/nexmoe/js/common.js?1590205324215"
        charset="utf-8"></script>
<script>
  var Label = {
    servePath: "https://chaihaobo.github.io",
    staticServePath: "https://chaihaobo.github.io",
    luteAvailable: false,
    hljsStyle: 'github',
    langLabel: "zh_CN",
    version: "4.1.0",
    staticSite: true,
    showCodeBlockLn: false,
  }
</script>
<link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/kanbanniang@0.2.8/index.css"/>
<script async src="https://cdn.jsdelivr.net/npm/kanbanniang@0.2.8/index.js"></script>
<div class="solo-kanbanniang">
    <div class="solo-kanbanniang__tip"></div>
    <canvas id="soloKanbanniang" width="280" height="250"></canvas>
    <div class="solo-kanbanniang__tool">
        <svg id="soloKanbanniangHome" viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M32 18.967l-16-12.42-16 12.42v-5.064l16-12.42 16 12.42zM28 18.516v12h-8v-8h-8v8h-8v-12l12-9z"></path>
        </svg>
        <svg id="soloKanbanniangRSS" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M320.364 768q0 45.728-32 77.728t-77.728 32-77.728-32-32-77.728 32-77.728 77.728-32 77.728 32 32 77.728zM612.94 838.272q1.152 16-9.728 27.424-10.272 12-26.848 12h-77.152q-14.272 0-24.576-9.44t-11.424-23.712q-12.576-130.848-105.44-223.712t-223.712-105.44q-14.272-1.152-23.712-11.424t-9.44-24.576V402.24q0-16.576 12-26.848 9.728-9.728 24.576-9.728h2.848q91.424 7.424 174.848 46.016t148 103.712q65.152 64.576 103.712 148t46.016 174.848z m292.576 1.152q1.152 15.424-10.272 26.848-10.272 11.424-26.272 11.424h-81.728q-14.848 0-25.44-10.016t-11.136-24.288q-6.848-122.848-57.728-233.44t-132.288-192-192-132.288-233.44-58.272q-14.272-0.576-24.288-11.136t-10.016-24.864V109.664q0-16 11.424-26.272 10.272-10.272 25.152-10.272h1.728q149.728 7.424 286.56 68.576t243.136 168q106.848 106.272 168 243.136t68.576 286.56z"></path>
        </svg>
        <svg id="soloKanbanniangChat" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M802.42709 96.163153H219.476155c-84.48109 0-154.896836 71.746044-154.896836 157.840888v393.119449c0 86.072331 70.415746 157.819398 154.896836 157.819399h214.038818V925.470963s22.526039 40.168862 64.767096 5.734608c30.965246-25.819039 126.721123-91.828428 171.775248-123.385145h132.369773c84.502579 0 154.896836-83.21526 154.896836-157.839865V251.125481c0-86.094844-70.394257-154.962328-154.896836-154.962328zM301.144176 518.002714c-39.427988 0-70.416769-31.576159-70.416769-71.746044 0-40.168862 30.988782-71.746044 70.416769-71.746044 39.426965 0 70.393233 31.577183 70.393234 71.746044 0 40.169885-30.966269 71.746044-70.393234 71.746044z m208.411657 0c-39.450501 0-70.415746-31.576159-70.415746-71.746044 0-40.168862 30.965246-71.746044 70.415746-71.746044 39.405475 0 70.394257 31.577183 70.394257 71.746044 0 40.169885-30.988782 71.746044-70.394257 71.746044z m211.203236 0c-39.426965 0-70.416769-31.576159-70.416769-71.746044 0-40.168862 30.988782-71.746044 70.416769-71.746044s70.415746 31.577183 70.415746 71.746044c-0.001023 40.169885-30.988782 71.746044-70.415746 71.746044z"></path>
        </svg>
        <svg id="soloKanbanniangChange" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M936.672 193.216l-226.88-64c-8.704-2.528-18.112-1.12-25.824 3.776-7.68 4.864-12.896 12.736-14.432 21.728C655.712 236.928 595.328 288 512 288c-71.424 0-142.464-103.296-163.776-143.104-7.136-13.28-22.528-19.84-37.024-15.68l-224 64C73.472 197.152 64 209.728 64 224v256a31.93 31.93 0 0 0 11.712 24.736c7.392 6.08 17.152 8.512 26.56 6.624L224 487.04V832c0 52.928 43.072 96 96 96h384c52.928 0 96-43.072 96-96V519.04l121.728 24.352c9.44 1.92 19.2-0.544 26.56-6.624C955.68 530.656 960 521.6 960 512V224c0-14.336-9.536-26.912-23.328-30.784zM672 800H352c-17.664 0-32-14.304-32-32s14.336-32 32-32h320c17.696 0 32 14.304 32 32s-14.304 32-32 32z"></path>
        </svg>
        <svg id="soloKanbanniangPhoto" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M898.048 258.048q23.552-1.024 46.592 9.216t40.96 27.136 28.672 39.424 10.752 46.08l0 390.144q0 24.576-10.752 47.104t-28.672 40.448-40.96 28.16-47.616 10.24l-697.344 0q-24.576 0-48.64-10.24t-42.496-27.648-29.696-40.448-11.264-48.64l0-381.952q0-22.528 10.752-45.568t28.672-41.472 39.936-30.208 44.544-11.776l63.488 0 13.312-83.968q3.072-20.48 18.432-32.768t34.816-12.288l456.704 0q19.456 0 34.304 10.752t16.896 34.304l14.336 83.968 54.272 0zM548.864 712.704q40.96 0 77.824-15.872t63.488-42.496 42.496-62.976 15.872-77.312-15.872-77.312-42.496-62.976-63.488-42.496-77.824-15.872-77.312 15.872-63.488 42.496-43.008 62.976-15.872 77.312 15.872 77.312 43.008 62.976 63.488 42.496 77.312 15.872z"></path>
        </svg>
        <svg id="soloKanbanniangGithub" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M1024 524.8c0 114.346667-32.554667 217.216-97.706667 308.565333-65.066667 91.306667-149.162667 154.538667-252.288 189.610667-11.989333 2.304-20.778667 0.682667-26.325333-4.778667a27.605333 27.605333 0 0 1-8.362667-20.48v-144.213333c0-44.16-11.52-76.501333-34.645333-97.024 25.344-2.730667 48.085333-6.826667 68.309333-12.288a268.629333 268.629333 0 0 0 62.72-26.666667 187.434667 187.434667 0 0 0 53.973334-45.44c14.421333-18.005333 26.197333-41.898667 35.328-71.765333 9.088-29.824 13.653333-64.128 13.653333-102.826667 0-55.125333-17.536-102.058667-52.650667-140.8 16.426667-41.429333 14.677333-87.893333-5.333333-139.392-12.458667-4.096-30.464-1.578667-54.016 7.509334a355.328 355.328 0 0 0-61.312 30.08L640 271.274667a462.336 462.336 0 0 0-128-17.749334c-43.989333 0-86.656 5.930667-128 17.749334a589.824 589.824 0 0 0-28.330667-18.432c-11.776-7.253333-30.336-16.042667-55.68-26.325334-25.344-10.24-44.416-13.312-57.301333-9.216-19.584 51.498667-21.12 97.962667-4.693333 139.434667-35.114667 38.698667-52.650667 85.632-52.650667 140.757333 0 38.698667 4.565333 72.874667 13.653333 102.485334 9.130667 29.610667 20.778667 53.546667 34.986667 71.765333 14.250667 18.218667 32.128 33.493333 53.674667 45.781333 21.546667 12.288 42.453333 21.205333 62.677333 26.666667 20.224 5.461333 43.008 9.557333 68.309333 12.288-17.749333 16.384-28.629333 39.850667-32.64 70.4a130.005333 130.005333 0 0 1-29.994666 10.24c-10.666667 2.261333-23.338667 3.413333-37.973334 3.413333-14.72 0-29.269333-4.906667-43.690666-14.677333-14.464-9.813333-26.794667-24.064-36.992-42.709333a109.226667 109.226667 0 0 0-32.341334-35.541334c-13.141333-9.130667-24.106667-14.592-33.024-16.426666l-13.312-2.048c-9.344 0-15.786667 1.024-19.328 3.072-3.584 2.090667-4.693333 4.693333-3.328 7.893333 1.28 3.157333 3.328 6.4 5.973334 9.557333 2.688 3.2 5.546667 5.930667 8.661333 8.192l4.693333 3.413334c9.770667 4.565333 19.413333 13.226667 29.013334 25.984 9.514667 12.757333 16.512 24.362667 20.992 34.858666l6.656 15.701334c5.76 17.322667 15.530667 31.317333 29.312 42.026666 13.781333 10.666667 28.672 17.536 44.672 20.48 16 2.986667 31.445333 4.565333 46.336 4.821334 14.890667 0.213333 27.221333-0.597333 36.992-2.389334l15.36-2.730666c0 17.28 0.085333 37.546667 0.298666 60.8l0.341334 36.906666a27.050667 27.050667 0 0 1-8.661334 20.48c-5.76 5.461333-14.677333 7.082667-26.666666 4.778667-103.125333-35.072-187.221333-98.261333-252.330667-189.610667C32.554667 742.058667 0 639.146667 0 524.8c0-95.232 22.869333-183.04 68.693333-263.466667A516.266667 516.266667 0 0 1 254.976 70.4C333.44 23.466667 419.114667 0 512 0c92.885333 0 178.56 23.466667 256.981333 70.4a516.266667 516.266667 0 0 1 186.368 190.976C1001.130667 341.802667 1024 429.653333 1024 524.842667z"></path>
        </svg>
        <svg id="soloKanbanniangClose" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M517.572566143763 1018.6748601482986C238.26554897656422 1018.6748601482986 11.897910175114305 792.2714997690043 11.897910175114305 513.0002041796496c0-279.3070171671984 226.36763880144977-505.71037754649296 505.6746559686481-505.71037754649296 279.2712955893538 0 505.6746559686481 226.40336037929444 505.6746559686481 505.71037754649296C1023.2472221124112 792.2714997690043 796.8795833109612 1018.6748601482986 517.572566143763 1018.6748601482986zM754.7281214542927 339.25044954334646c13.752807470184345-13.752807470184345 9.680547595895998-40.186775075214015-9.073280772537204-58.94060344364717l-2.143294670678079-2.1075730928334457c-18.7538283684332-18.7538283684332-45.15207439561819-22.861809820566194-58.90488186580257-9.073280772537204l-168.21291007038468 168.24863164822932-180.42968969324974-180.46541127109438c-13.967136937252159-13.967136937252159-40.72259874288353-9.823433907274534-59.72647815622916 9.216167083915742l-2.143294670678079 2.143294670678079c-19.039600991190277 19.003879413345654-23.111860865478626 45.75934121897699-9.180445506071107 59.655035000539876l180.42968969324974 180.46541127109438-176.07165719620428 176.03593561835962c-13.788529048028984 13.824250625873615-9.716269173740633 40.151053497369375 9.073280772537204 58.94060344364717l2.1075730928334457 2.1075730928334457c18.7538283684332 18.7538283684332 45.15207439561819 22.897531398410823 58.90488186580257 9.073280772537204l176.10737877404887-176.10737877404887 170.39192631890742 170.42764789675192c13.967136937252159 13.931415359407513 40.686877165038865 9.85915548511917 59.690756578384516-9.180445506071107l2.1790162485227142-2.1790162485227142c19.039600991190277-18.968157835501014 23.147582443323273-45.72361964113239 9.180445506071107-59.690756578384516l-170.39192631890742-170.42764789675192L754.7281214542927 339.25044954334646z"></path>
        </svg>
    </div>
</div>

<script>
    console.clear();
</script>
<script type="text/javascript">
    Util.addScript('https://chaihaobo.github.io/js/page.min.js?1590205324215', 'soloPageScript')
    var page = new Page({
        "commentContentCannotEmptyLabel": "评论内容只能为 2 到 500 个字符！",
        "oId": "1590412102084",
        "blogHost": "https://chaihaobo.github.io",
        "randomArticles1Label": "随机阅读：",
        "externalRelevantArticles1Label": "站外相关阅读："
    });
    $(document).ready(function () {
        page.load();
    page.tips.externalRelevantArticlesDisplayCount = "0";
    Skin.initArticle()
    });
</script>

</body>
</html>

<!-- Generated by Latke (https://github.com/88250/latke) in 26ms, 2020/05/26 14:10:46 -->